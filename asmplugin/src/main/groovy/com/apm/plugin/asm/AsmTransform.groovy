package com.apm.plugin.asmimport com.android.build.api.transform.Contextimport com.android.build.api.transform.DirectoryInput;import com.android.build.api.transform.Formatimport com.android.build.api.transform.JarInput;import com.android.build.api.transform.QualifiedContent;import com.android.build.api.transform.Transform;import com.android.build.api.transform.TransformExceptionimport com.android.build.api.transform.TransformInputimport com.android.build.api.transform.TransformInvocation;import com.android.build.api.transform.TransformOutputProvider;import com.android.build.gradle.internal.pipeline.TransformManager;import org.apache.commons.io.FileUtilsimport org.apache.commons.codec.digest.DigestUtilsimport org.gradle.api.Projectclass AsmTransform extends Transform {    private String TAG = "AsmTransform";    public setTag(String tag){        TAG = tag    }    @Override    String getName() {        return "ASM-TransFor"    }    @Override    Set<QualifiedContent.ContentType> getInputTypes() {        return TransformManager.CONTENT_CLASS    }    @Override    Set<? super QualifiedContent.Scope> getScopes() {        return TransformManager.SCOPE_FULL_PROJECT    }    @Override    boolean isIncremental() {        return false    }//    @Override//    void transform(Context context, Collection<TransformInput> inputs, Collection<TransformInput> referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental) throws IOException, TransformException, InterruptedException {//        super.transform(context, inputs, referencedInputs, outputProvider, isIncremental)//        System.out.println("----------------asm transform start--------------")////        inputs.each { TransformInput input ->//            input.directoryInputs.each { DirectoryInput directoryInput ->//                String path = directoryInput.file.absolutePath//                if(!path.contains("/build/tmp/")){//                    AsmMethodLog.addMonitorByteCode(path)//                    def dest = outputProvider.getContentLocation(directoryInput.name,//                            directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)//                    FileUtils.copyDirectory(directoryInput.file, dest)//                }else{//                    System.out.println("path = "+path)//                    System.out.println("这个里面是kotlin的代码，暂时还没搞定")//                }//            }////            input.jarInputs.each { JarInput jarInput ->//                def jarName = jarInput.name//                println("jar = " + jarInput.file.getAbsolutePath())//                def md5Name = DigestUtils.md5Hex(jarInput.file.getAbsolutePath())//                if (jarName.endsWith(".jar")) {//                    jarName = jarName.substring(0, jarName.length() - 4)//                }//                def dest = outputProvider.getContentLocation(jarName + md5Name, jarInput.contentTypes, jarInput.scopes, Format.JAR)//                FileUtils.copyFile(jarInput.file, dest)//            }//        }//        System.out.println("--------------asm transform over----------------")//    }    @Override    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException {        super.transform(transformInvocation);        //当前是否是增量编译        boolean isIncremental = transformInvocation.isIncremental();        System.out.println("current is incremental = " + isIncremental);        //消费型输入，可以从中获取jar包和class文件夹路径。需要输出给下一个任务        def inputs = transformInvocation.getInputs();        //引用型输入，无需输出。        def referencedInputs = transformInvocation.getReferencedInputs();        //OutputProvider管理输出路径，如果消费型输入为空，你会发现OutputProvider == null        def outputProvider = transformInvocation.getOutputProvider();        inputs.forEach() {            it.jarInputs.forEach() { jarInput ->                def dest = outputProvider.getContentLocation(jarInput.file.absolutePath, jarInput.contentTypes, jarInput.scopes, Format.JAR);                def inputFile = jarInput.file                println(TAG + " :skip jar is" + inputFile.getPath() + inputFile.getName());                FileUtils.copyFile(inputFile, dest);            }            it.directoryInputs.forEach() { dirInput ->                def dest = outputProvider.getContentLocation(dirInput.file.absolutePath, dirInput.contentTypes, dirInput.scopes, Format.DIRECTORY);                def dirInputFile = dirInput.file                if (dirInputFile.isDirectory()) {                    dirInputFile.eachFileRecurse { inputClassFile ->                        if(inputClassFile.name.endsWith("class")){                            AsmMethodLog.addMonitorByteCode(inputClassFile,TAG)                        }                    }                } else {                    println(TAG + " :action class is" + dirInputFile.getPath() + dirInputFile.getName());                }                FileUtils.copyDirectory(dirInputFile, dest)            }        }    }}